Title: 尾递归
Date: 2014-03-07 10:20
Category: Algorithm
Tags: Algorithm

最近有同学去面试，被问到[斐波那契数列](http://zh.wikipedia.org/zh/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97)的递归求法。其实大多数人会认为这个非常简单，很快给出答案。如下：

根据定义很容易写出的斐波那契数列:

    :::cpp
    int Fibonacci(int n) {
        if (n<=2) {
            return 1;
        }
        else {
            return Fibonacci(n-1) + Fibonacci(n-2);
        }
    }

但是面试官接着问这样不断的压栈很浪费内存空间，问是否可以优化？可能很多人给不出其他解法了，或者说感觉其他解法如果也是递归的话，也需要压栈，一样会占用内存空间。其实，面试官想考察的是<code>尾递归</code>。
###什么是[尾递归](http://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8) ？
>在计算机科学里，尾调用是指一个函数里的最后一个动作是一个函数调用的情形即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为尾位置。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，是递归的一种特殊情形。尾调用不一定是递归调用，但是尾递归特别有用，也比较容易实现。

>尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。尾递归因而具有两个特征：
调用自身函数(Self-called)；
计算仅占用常量栈空间(Stack Space)。
而形式上只要是最后一个return语句返回的是一个完整函数，它就是尾递归。

简单理解，就是处于函数尾部的递归调用本身的情形下，前面的变量状态都不需要再保存了，可以释放，从而节省很大的内存空间。在前面的代码中，明显在调用递归调用<code>Fibonacci(n-1)</code>的时候，还有<code>Fibonacci(n-2)</code>没有执行，需要保存前面的状态，因此开销较大的。

于是，我们可以改写这个斐波那契数列：
    :::cpp
    int Fibonacci(int n, int a, int b) {
        if (n<=2) {
            return b;
        }
        else {
            return Fibonacci(n-1, b, a+b);
        }
    }

详细的可以参考上面给出的[尾递归](http://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)链接。