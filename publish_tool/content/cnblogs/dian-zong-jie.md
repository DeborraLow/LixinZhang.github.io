Title: 一点总结
Date: 2011-02-27 12:22
Author: 糖拌咸鱼
Slug: dian-zong-jie

**系统是如何找到头文件的：**

</p>

　　当我们自定义一个头文件的时候，系统是如何找到这个头文件的呢？  其实
，我们可以发现我们在预处理\#include"head.h"
用的是双引号，而不是尖括号  是因为，当用双引号的时候，系统会首先在文件所在的目录下寻找该头文件。如果找不到，预处理器会在c++标准库头文件中去继续寻找  而当我们使用尖括号的时候，系统只会在c++标准库头文件中去寻找！

</p>

**获取系统时间：**

</p>

** **

</p>

<div class="cnblogs_code">

</p>
<p>
    #include<iostream>#include "ctime"using namespace std;int main(void){   tm *local;   time_t t;   t=time(NULL);   local=localtime(&t);   cout<<local->tm_year+1900;   return 0;}

</p>
<p>

</div>

</p>
**  
**

**关于static：**

</p>

　　静态成员 是属于整个类的 它不属于对象  所以staitc成员函数
只能访问static数据  而不能访问对象中的数据我们可以这么解释一下 首先
static 是所有对象所共有的  当让它访问一个对象中的非static数据
系统无法判断这个数据到底属于谁 所以也就无法访问 

</p>

**关于c++引用的一些概念：**

</p>

引用（reference）是c++对c语言的重要扩充  
引用并不是产生对象的副本，仅仅是对象的同义词。  
引用必须在定义时马上进行初始化，不能先定义一个引用后，才初始化它。

</p>

当大型对象被传递给函数时，使用引用参数可使参数传递效率得到提高，因为引用并不产生对象的副本，也就是参数传递时，对象无须复制。  
　　**引用返回值** 如果一个函数返回了引用，那么该函数的调用也可以被赋值。这里有一函数，它拥有两个引用参数并返回一个双精度数的引用：

</p>

double &max(double &d1,double &d2)

</p>

{return d1\>d2?d1:d2;}

</p>

由于max()函数返回一个对双精度数的引用，那么我们就可以用max()
来对其中较大的双精度数加1：max(x,y)+=1.0;

</p>

在定义类的函数时，千万要注意的是不能返回私有数据的引用，因为这样的话，等于将私有数据暴露在了外界，因此封装性就被破坏了，是极其危险的。

</p>

**多态性的定义：**

</p>

所谓多态性是指由于继承而关联在一起的不同类的对象，对于相同的成员函数调用做出不同反应的一种能力。  
　　每个含有virtual函数的类的对象，都含有一个指向该类的vtable的指针。当有指向派生类对象的的基类指针进行一次函数的调用。vtable中相应的函数指针可以执行期间获得，然后间接引用该指针，从而完成这次函数调用。vtable的检索和指针的间接引用只占用很少的运行时间。

</p>

**关于虚函数：**

</p>

virtual double getMoney() const = 0;  
　　"=0"即将该函数定义为了一个纯虚函数，纯虚函数必须在后面的继承类中加以override我们需要注意的是
这个必须一词如果存在纯虚函数而没有对其进行重载
编译器将导致一个严重的错误  
　　所以 我们在定义一个纯虚函数的时候 一定要考虑到实际情况 也就是说
对于一个方法或者函数
 我们知道是一个必须使用的，而且不可删除的是需要程序员在后来的定义中必须要重新重载的。  
　　而关于抽象类  我们说 是一种永远都不会 直接实例化的一种类
是需要继承的 所以在抽象类中提供一种虚函数是必要的  
　　而对于前面已经定义的虚函数而言，我们在继承类中经常习惯的将重载的函数前仍加上关键字
virtual 注意 这里我们加入该关键字
并不是因为是程序所必须要求的，而是出于良好的编程习惯而言也就是说
在基类中 已经定义了虚函数 后面就可以不必再定义了 而为了增强程序的可读性
所以经常习惯的加上<span></span>virtual  
　　良好的编程习惯：如果一个类含有virtual函数，该类就要提供一个virtual析构函数，即使该析构函数并不一定是该类需要的。从这个类可以包含析构函数，但是必须正确调用。

</p>

**函数模板和模板函数：**

</p>

　　函数模板提供了一类函数的抽象，它提供了任意类型为参数及返回值。

</p>

　　函数模板经实例化后生成的具体函数成为模板函数。

</p>

　　函数模板代表了一类函数，模板函数表示某一具体函数。 

</p>

　　1.当编译器遇到template关键字的时候，编译器只是简单的知道，它不会产生任何的代码
因为它根本不知道T为何类型

</p>

　　2.编译器只在第一次调用时生成模板函数
当之后遇到相同类型的参数调用时，不再生成其他的模板函数
将直接调用第一次生成的那个

</p>

　　3.模板参数的匹配问题  普通函数 有些类型自动的转换

</p>

